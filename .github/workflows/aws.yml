# Terraform Action to test Cloud Databases with test-harness

name: AWS Cloud Database Test Execution
concurrency: aws-run
on:
  # Triggers the workflow on a schedule for the main branch. Also allows for manual triggers
  schedule:
    - cron: '0 6 * * *' # Execute every day at 6AM UTC
  repository_dispatch:
    types: [test-harness]
  workflow_dispatch:
    inputs:
      testClasses:
        type: choice
        description: Test Suite or test class to run
        options:
          - LiquibaseHarnessSuiteTest
          - FoundationalHarnessSuiteTest
          - AdvancedHarnessSuiteTest
          - ChangeObjectTests
          - ChangeDataTests
          - SnapshotObjectTests
          - GenerateChangelogTest
          - FoundationalTest
      databases:
        description: Databases to start up. Comma separated list of "name:version"
        required: true
        default: "[\"postgresql:12\",\"postgresql:13\",\"postgresql:14\",\"postgresql:16\",\"postgresql:17\",\"oracle:aws_19\",\"mariadb:aws_10.6\",\"mysql:aws\",\"mysql:aurora\",\"mssql:aws_2019\",\"postgresql:aurora_16\",\"postgresql:aurora_17\"]"

permissions:
  contents: write
  id-token: write
  
jobs:
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      databases: ${{ github.event.inputs.databases || '["postgresql:12","postgresql:13","postgresql:14","postgresql:16","postgresql:17","oracle:aws_19",
        "mariadb:aws_10.6","mysql:aws","mysql:aurora","mssql:aws_2019","postgresql:aurora_16","postgresql:aurora_17"]' }}
      testClasses: ${{ inputs.testClasses  || 'LiquibaseHarnessSuiteTest' }}
      triggeredRepo: ${{ steps.configure-build.outputs.triggeredRepo }}
      useProArtifacts: ${{ steps.configure-build.outputs.useProArtifacts }}
      liquibaseRepo: ${{ steps.configure-build.outputs.liquibaseRepo }}
      proVersion: ${{ steps.discover-version.outputs.secure-version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Get GitHub App token
        id: get-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.LIQUIBASE_GITHUB_APP_ID }}
          private-key: ${{ env.LIQUIBASE_GITHUB_APP_PRIVATE_KEY }}
          owner: liquibase
          repositories: liquibase,liquibase-pro,liquibase-test-harness
          permission-contents: read
          permission-actions: read
          permission-statuses: write

      - name: Configure Build
        id: configure-build
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}
          script: |
            const helper = require('./.github/util/workflow-helper.js')({github, context});

            let testBranchName = helper.getCurrentBranch();
            console.log("Running in liquibase-test-harness branch " + testBranchName);
            core.notice("Running in liquibase-test-harness branch " + testBranchName);

            // Detect which repository triggered this workflow
            const triggeredRepo = helper.getTriggeredRepository();
            console.log("Workflow triggered by repository: " + triggeredRepo);
            core.notice("Workflow triggered by repository: " + (triggeredRepo || "liquibase-test-harness (current repo)"));

            // Determine default repo based on triggered repository
            const defaultRepo = helper.getDefaultRepoForContext(triggeredRepo);
            const useProArtifacts = helper.shouldUseProArtifacts(triggeredRepo);
            console.log("Default repo for artifacts: " + defaultRepo);
            console.log("Using SECURE artifacts: " + useProArtifacts);

            // Use manual input if provided, otherwise use detected default
            let liquibaseRepo = "${{ github.event.inputs.liquibaseRepo }}" || defaultRepo;
            console.log("liquibaseRepo == " + liquibaseRepo);

            // Track the user's intended repository for artifact selection
            let userSelectedRepo = "${{ github.event.inputs.liquibaseRepo }}" || null;
            let intentProArtifacts = userSelectedRepo ? helper.shouldUseProArtifacts(userSelectedRepo) : useProArtifacts;
            console.log("User intended SECURE artifacts: " + intentProArtifacts);

            // Determine if user explicitly selected liquibase-pro (no fallback allowed)
            let isExplicitProSelection = userSelectedRepo && helper.shouldUseProArtifacts(userSelectedRepo);
            console.log("Explicit SECURE selection (no fallback allowed): " + isExplicitProSelection);

            core.setOutput("triggeredRepo", triggeredRepo || "liquibase-test-harness");

            let liquibaseBranchName = "${{ github.event.inputs.liquibaseBranch }}" || testBranchName + ", master";
            console.log("liquibaseBranch == " + liquibaseBranchName);
            core.setOutput("liquibaseBranch", liquibaseBranchName);

            let repoOwnerName = liquibaseRepo.split("/")[0]
            let repoName = liquibaseRepo.split("/")[1]

            let liquibaseSha = "${{ github.event.inputs.liquibaseCommit }}";
            if (!liquibaseSha) {
              console.log("No liquibaseSha passed. Looking for branch "+ liquibaseBranchName);

              try {
                let liquibaseBranchResponse = await helper.findMatchingBranch(repoOwnerName, repoName, [liquibaseBranchName, "master", "main"]);
                liquibaseSha = liquibaseBranchResponse.sha;
              } catch (error) {
                // If branch lookup fails and user explicitly selected liquibase-pro, fail hard
                // (don't fall back to community repo)
                if (isExplicitProSelection) {
                  core.error("Failed to find branch in explicitly selected liquibase-pro repository");
                  core.error("Error: " + error.message);
                  core.error("When you explicitly select liquibase-pro, artifacts must come from that repository only.");
                  core.error("Please verify that:");
                  core.error("  1. The branch exists in liquibase-pro");
                  core.error("  2. The LIQUIBOT_PAT_GPM_ACCESS token has access to liquibase-pro");
                  throw new Error("Cannot fall back from explicitly selected liquibase-pro repository");
                }

                // For triggered or default selections, allow fallback to default repository
                console.warn("Failed to find branch in " + liquibaseRepo + ": " + error.message);

                if (liquibaseRepo !== defaultRepo) {
                  console.log("Falling back to default repository: " + defaultRepo);
                  const fallbackOwner = defaultRepo.split("/")[0];
                  const fallbackRepo = defaultRepo.split("/")[1];

                  try {
                    let liquibaseBranchResponse = await helper.findMatchingBranch(fallbackOwner, fallbackRepo, [liquibaseBranchName, "master", "main"]);
                    liquibaseSha = liquibaseBranchResponse.sha;
                    liquibaseRepo = defaultRepo;
                    repoOwnerName = fallbackOwner;
                    repoName = fallbackRepo;
                    core.notice("Switched to fallback repository: " + defaultRepo + " for branch lookup, but will use " + (intentProArtifacts ? "pro" : "community") + " artifacts");
                    console.log("Successfully found branch in fallback repo");
                  } catch (fallbackError) {
                    core.error("Failed to find branch in both " + liquibaseRepo + " and fallback " + defaultRepo);
                    throw fallbackError;
                  }
                } else {
                  throw error;
                }
              }
            }
            core.setOutput("liquibaseSha", liquibaseSha);
            core.setOutput("liquibaseRepo", liquibaseRepo);
            // Use the user's intended SECURE artifacts setting
            core.setOutput("useProArtifacts", intentProArtifacts);
            core.setOutput("liquibaseOwner", repoOwnerName);

            let runDescription = "${{ github.event.inputs.runDescription }}";
            if (!runDescription) {
                runDescription = "None given";
            }
            core.notice("Triggered by this OSS PR: " + runDescription);

            let runDetails = null;
            if (context.payload && context.payload.inputs && context.payload.inputs.runDetails) {
                runDetails = JSON.parse(context.payload.inputs.runDetails);
            }
            if (!runDetails) {
              runDetails = {};

            }
            if (runDetails.notices) {
                for (let notice of runDetails.notices) {
                    core.notice(notice);
                }
            }

      - name: maven-settings-xml-action
        uses: whelk-io/maven-settings-xml-action@v22
        with:
          repositories: |
            [
              {
                "id": "github",
                "url": "https://maven.pkg.github.com/liquibase/liquibase",
                "releases": {
                  "enabled": "true"
                },
                "snapshots": {
                  "enabled": "true",
                  "updatePolicy": "always"
                }
              }
            ]
          servers: |
            [
              {
                "id": "github",
                "username": "liquibot",
                "password": "${{ env.LIQUIBOT_PAT_GPM_ACCESS }}"
              }
            ]

      - uses: actions/setup-java@v5
        with:
          java-version: "17"
          distribution: "temurin"
          cache: "maven"

      - name: Discover Liquibase Version
        id: discover-version
        env:
          GITHUB_TOKEN: ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}
        run: |
          echo "::group::Discover Liquibase Snapshot Version"

          # AWS cloud tests ALWAYS use Pro artifacts
          echo "AWS cloud tests always use PRO artifacts (liquibase-commercial)"
          echo "Skipping COMMUNITY artifact discovery; liquibase-core is bundled with liquibase-commercial."

          # Query GitHub Packages for the latest liquibase-commercial artifact version
          PACKAGES_URL="https://maven.pkg.github.com/liquibase/liquibase-pro/com/liquibase/liquibase-commercial/maven-metadata.xml"

          echo "Fetching latest PRO artifact version from: $PACKAGES_URL"
          METADATA=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$PACKAGES_URL")

          # Extract version in master-{7-char-hex-sha} format (e.g., master-e461cb2)
          SECURE_VERSION=$(echo "$METADATA" | grep -o '<version>master-[a-f0-9]\{7\}</version>' | tail -1 | sed 's/<[^>]*>//g')

          if [ -z "$SECURE_VERSION" ]; then
            echo "ERROR: Could not determine PRO version from GitHub Packages"
            echo "Looking for pattern: master-{7-char-hex-sha} (e.g., master-e461cb2)"
            echo "GitHub Packages metadata response (first 500 chars):"
            echo "$METADATA" | head -c 500
            echo ""
            exit 1
          fi

          echo "PRO version: $SECURE_VERSION"
          echo "secure-version=$SECURE_VERSION" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Resolve Snapshot Liquibase Dependencies
        env:
          GITHUB_TOKEN: ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}
        run: |
          echo "::group::Resolve Snapshot Liquibase Dependencies"
          echo "Artifact repository: ${{ steps.configure-build.outputs.liquibaseRepo }}"
          echo "PRO version: ${{ steps.discover-version.outputs.secure-version }}"
          echo "AWS cloud tests ALWAYS use PRO artifacts"
          echo "::endgroup::"

          # Verify Maven settings are configured
          echo "Maven settings.xml location:"
          ls -la ~/.m2/settings.xml || echo "No settings.xml found"
          echo "Maven settings.xml content:"
          cat ~/.m2/settings.xml || echo "Could not read settings.xml"

          # Pass authentication credentials as system properties to Maven
          MAVEN_AUTH_OPTS="-Dorg.slf4j.simpleLogger.defaultLogLevel=debug"

          echo "Resolving PRO artifacts from liquibase-pro repository..."
          echo "Skipping liquibase-core resolution; liquibase-commercial already bundles liquibase-core."

          # âœ… Explicitly activate useProArtifacts profile and set commercial version
          mvn -B \
            -PuseProArtifacts \
            -DuseProArtifacts=true \
            -Dliquibase-commercial.version=${{ steps.discover-version.outputs.secure-version }} \
            $MAVEN_AUTH_OPTS \
            dependency:resolve \
            -DincludeArtifactIds=liquibase-commercial \
            -DexcludeArtifactIds=liquibase-core 2>&1 | tee resolve.log

          echo ""
          echo "::group::Dependency Tree (PRO - liquibase-commercial)"
          mvn -B \
            -PuseProArtifacts \
            -DuseProArtifacts=true \
            -Dliquibase-commercial.version=${{ steps.discover-version.outputs.secure-version }} \
            dependency:tree 2>&1 | grep -E "(liquibase|BUILD SUCCESS)" || true
          echo "::endgroup::"

          echo "::notice :: Resolved Snapshot Liquibase PRO dependencies"

      - name: Cache installed Liquibase
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository/
          key: mvn-liquibase-${{ github.run_id }}-${{ github.run_attempt }}

  test:
    needs: [setup]
    runs-on: ubuntu-latest
    env:
      LPM_VERSION: 0.2.3
    strategy:
      fail-fast: false
      matrix:
        database: ${{ fromJson(needs.setup.outputs.databases) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Python
        uses: actions/setup-python@v6.0.0
        with:
          python-version: '3.11.5'
    
      - name: Install liquibase and lpm
        run: |
          wget -O- https://repo.liquibase.com/liquibase.asc | gpg --dearmor > liquibase-keyring.gpg && \
          cat liquibase-keyring.gpg | sudo tee /usr/share/keyrings/liquibase-keyring.gpg > /dev/null && \
          echo 'deb [arch=amd64 signed-by=/usr/share/keyrings/liquibase-keyring.gpg] https://repo.liquibase.com stable main' | sudo tee /etc/apt/sources.list.d/liquibase.list
          sudo apt-get update
          sudo apt-get install liquibase
          curl -L -o lpm-${{ env.LPM_VERSION }}-linux.zip https://github.com/liquibase/liquibase-package-manager/releases/download/v${{ env.LPM_VERSION }}/lpm-${{ env.LPM_VERSION }}-linux.zip
          sudo unzip -o lpm-${{ env.LPM_VERSION }}-linux.zip -d /usr/bin
          sudo lpm update && sudo lpm add mysql postgresql
    
      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Start & Configure LocalStack
        env:
          LOCALSTACK_OAUTH_TOKEN: ${{ env.LOCALSTACK_OAUTH_TOKEN }}
          GITHUB_TOKEN: ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}
          RDS_MYSQL_DOCKER: 1     #https://docs.localstack.cloud/user-guide/aws/rds/#mysql-engine
        run: |
          pip install localstack awscli-local
          docker pull localstack/localstack-pro
          docker pull mcr.microsoft.com/mssql/server:2019-latest
          DOCKER_FLAGS='-e MSSQL_ACCEPT_EULA=Y -e MSSQL_IMAGE=mcr.microsoft.com/mssql/server:2019-latest -e LOCALSTACK_OAUTH_TOKEN=${{ env.LOCALSTACK_OAUTH_TOKEN }}' 
          localstack auth set-token ${{ env.LOCALSTACK_OAUTH_TOKEN }}
          MSSQL_ACCEPT_EULA=Y localstack start -d
          echo "Waiting for LocalStack startup..."
          localstack wait -t 30
          echo "Startup complete"
          echo "TH_DB_ADMIN=lbuser" >> $GITHUB_ENV  
          echo "TH_DB_PASSWD=test" >> $GITHUB_ENV
          echo "TH_DB_PASSWD_MSSQL=Test.2024" >> $GITHUB_ENV
          echo "TH_DB=lbcat" >> $GITHUB_ENV  
          echo "TH_AURORA_POSTGRESQL_16_ENGINE=16" >> $GITHUB_ENV
          echo "TH_AURORA_POSTGRESQL_17_ENGINE=17" >> $GITHUB_ENV
          echo "TH_MARIADB_ENGINE=10.6" >> $GITHUB_ENV
          echo "TH_MSSQL_ENGINE=2019" >> $GITHUB_ENV
          echo "TH_MYSQL_ENGINE=8.0" >> $GITHUB_ENV

      - name: Configure Test
        id: setup
        uses: actions/github-script@v8
        with:
          script: |
            let splitValues = "${{ matrix.database }}".split(":")
            core.setOutput("databasePlatform", splitValues[0]);
            core.setOutput("databaseVersion", splitValues[1]);

      - name: Init Aurora MySQL Database
        if: ${{ steps.setup.outputs.databasePlatform == 'mysql' && steps.setup.outputs.databaseVersion == 'aurora' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier aurora-mysql-primary-cluster --engine aurora-mysql --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier aurora-mysql-primary-cluster-instance --db-cluster-identifier aurora-mysql-primary-cluster --engine aurora-mysql --db-instance-class db.t3.medium
          aurora_mysql_port=$(awslocal rds describe-db-instances --db-instance-identifier aurora-mysql-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          aurora_mysql_url="jdbc:mysql://localhost:$aurora_mysql_port/${{ env.TH_DB }}"
          echo "TH_AURORA_MYSQLURL=$aurora_mysql_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="root" --password="${{ env.TH_DB_PASSWD }}" --url="$aurora_mysql_url" update

      - name: Init Aurora Postgresql Database
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion == 'aurora_16' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier aurora-postgresql-primary-cluster --engine aurora-postgresql --engine-version ${{ env.TH_AURORA_POSTGRESQL_16_ENGINE }} --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier aurora-postgresql-primary-cluster-instance --db-cluster-identifier aurora-postgresql-primary-cluster --engine aurora-postgresql --db-instance-class db.t3.medium
          aurora_postgresql_port=$(awslocal rds describe-db-instances --db-instance-identifier aurora-postgresql-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          aurora_postgresql_url="jdbc:postgresql://localhost:$aurora_postgresql_port/${{ env.TH_DB }}"
          echo "TH_AURORA_POSTGRESQL16URL=$aurora_postgresql_url" >> $GITHUB_ENV
          echo $TH_AURORA_POSTGRESQL16URL
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD }}" --url="$aurora_postgresql_url" update

      - name: Init Aurora Postgresql Database
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion == 'aurora_17' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier aurora-postgresql-primary-cluster --engine aurora-postgresql --engine-version ${{ env.TH_AURORA_POSTGRESQL_17_ENGINE }} --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier aurora-postgresql-primary-cluster-instance --db-cluster-identifier aurora-postgresql-primary-cluster --engine aurora-postgresql --db-instance-class db.t3.medium
          aurora_postgresql_port=$(awslocal rds describe-db-instances --db-instance-identifier aurora-postgresql-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          aurora_postgresql_url="jdbc:postgresql://localhost:$aurora_postgresql_port/${{ env.TH_DB }}"
          echo "TH_AURORA_POSTGRESQL17URL=$aurora_postgresql_url" >> $GITHUB_ENV
          echo $TH_AURORA_POSTGRESQL16URL
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD }}" --url="$aurora_postgresql_url" update          

      - name: Init MariaDB Database
        if: ${{ steps.setup.outputs.databasePlatform == 'mariadb' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier mariadb-primary-cluster --engine mariadb --engine-version ${{ env.TH_MARIADB_ENGINE }} --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier mariadb-primary-cluster-instance --db-cluster-identifier mariadb-primary-cluster --engine mariadb --db-instance-class db.t3.medium
          mariadb_port=$(awslocal rds describe-db-instances --db-instance-identifier mariadb-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          mariadb_url="jdbc:mariadb://localhost:$mariadb_port/${{ env.TH_DB }}"
          echo "TH_MARIADBURL_10_6=$mariadb_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD }}" --url="$mariadb_url" update

      - name: Init PostgreSQL 12 Database
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '12' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier postgres12-primary-cluster --engine postgres --engine-version 12 --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier postgres12-primary-cluster-instance --db-cluster-identifier postgres12-primary-cluster --engine postgres --db-instance-class db.t3.medium
          postgres12_port=$(awslocal rds describe-db-instances --db-instance-identifier postgres12-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          postgres12_url="jdbc:postgresql://localhost:$postgres12_port/${{ env.TH_DB }}"
          echo "TH_PGRESURL_12=$postgres12_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD }}" --url="$postgres12_url" update

      - name: Init PostgreSQL 13 Database
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '13' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier postgres13-primary-cluster --engine postgres --engine-version 13 --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier postgres13-primary-cluster-instance --db-cluster-identifier postgres13-primary-cluster --engine postgres --db-instance-class db.t3.medium
          postgres13_port=$(awslocal rds describe-db-instances --db-instance-identifier postgres13-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          postgres13_url="jdbc:postgresql://localhost:$postgres13_port/${{ env.TH_DB }}"
          echo "TH_PGRESURL_13=$postgres13_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD }}" --url="$postgres13_url" update

      - name: Init PostgreSQL 14 Database
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '14' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier postgres14-primary-cluster --engine postgres --engine-version 14 --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier postgres14-primary-cluster-instance --db-cluster-identifier postgres14-primary-cluster --engine postgres --db-instance-class db.t3.medium
          postgres14_port=$(awslocal rds describe-db-instances --db-instance-identifier postgres14-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          postgres14_url="jdbc:postgresql://localhost:$postgres14_port/${{ env.TH_DB }}"
          echo "TH_PGRESURL_14=$postgres14_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD }}" --url="$postgres14_url" update

      - name: Init PostgreSQL 16 Database
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '16' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier postgres16-primary-cluster --engine postgres --engine-version 16 --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier postgres16-primary-cluster-instance --db-cluster-identifier postgres16-primary-cluster --engine postgres --db-instance-class db.t3.medium
          postgres16_port=$(awslocal rds describe-db-instances --db-instance-identifier postgres16-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          postgres16_url="jdbc:postgresql://localhost:$postgres16_port/${{ env.TH_DB }}"
          echo "TH_PGRESURL_16=$postgres16_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD }}" --url="$postgres16_url" update

      - name: Init PostgreSQL 17 Database
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '17' }}
        run: |
          awslocal rds create-db-cluster --db-cluster-identifier postgres17-primary-cluster --engine postgres --engine-version 17 --database-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }}
          awslocal rds create-db-instance --db-instance-identifier postgres17-primary-cluster-instance --db-cluster-identifier postgres17-primary-cluster --engine postgres --db-instance-class db.t3.medium
          postgres17_port=$(awslocal rds describe-db-instances --db-instance-identifier postgres17-primary-cluster-instance  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          postgres17_url="jdbc:postgresql://localhost:$postgres17_port/${{ env.TH_DB }}"
          echo "TH_PGRESURL_17=$postgres17_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD }}" --url="$postgres17_url" update          

      - name: Init AWS RDS MSSQL 2019 Database
        if: ${{ steps.setup.outputs.databasePlatform == 'mssql'}}
        run: |
          awslocal rds create-db-instance --db-instance-identifier mssql2019 --engine sqlserver-ee --engine-version ${{ env.TH_MSSQL_ENGINE }}  --db-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD_MSSQL }} --db-instance-class db.t3.medium
          mssql2019_port=$(awslocal rds describe-db-instances --db-instance-identifier mssql2019  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          mssql2019_url="jdbc:sqlserver://;serverName=localhost;port=$mssql2019_port;trustServerCertificate=true;databaseName=${{ env.TH_DB }}"
          echo "TH_MSSQLURL=$mssql2019_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="${{ env.TH_DB_ADMIN }}" --password="${{ env.TH_DB_PASSWD_MSSQL }}" --url="$mssql2019_url" update

      - name: Init AWS RDS MySQL Database
        if: ${{ steps.setup.outputs.databasePlatform == 'mysql' && steps.setup.outputs.databaseVersion == 'aws' }}
        run: |
          awslocal rds create-db-instance --db-instance-identifier mysql --engine mysql --engine-version ${{ env.TH_MYSQL_ENGINE }}  --db-name ${{ env.TH_DB }} --master-username ${{ env.TH_DB_ADMIN }} --master-user-password ${{ env.TH_DB_PASSWD }} --db-instance-class db.t3.medium
          mysql_port=$(awslocal rds describe-db-instances --db-instance-identifier mysql  --query 'DBInstances[0].Endpoint.Port' | jq -r)
          mysql_url="jdbc:mysql://localhost:$mysql_port/${{ env.TH_DB }}"
          echo "TH_MYSQLURL_8_0=$mysql_url" >> $GITHUB_ENV
          sleep 30
          liquibase --classpath="src/test/resources/init-changelogs/aws" --changeLogFile="${{ steps.setup.outputs.databasePlatform }}.sql" --username="root" --password="${{ env.TH_DB_PASSWD }}" --url="$mysql_url" update

      - uses: liquibase-github-actions/drop-all@v4.33.0
        if: ${{ steps.setup.outputs.databasePlatform == 'oracle' }}
        with:
          url: "${{ env.TH_ORACLEURL_19 }}"
          username: "${{env.TH_DB_ADMIN}}"
          password: "${{env.TH_DB_PASSWD}}"
          licenseKey: "${{env.PRO_LICENSE_KEY}}"
          force: true
          requireForce: true

      - uses: liquibase/liquibase-github-action@v7
        if: ${{ steps.setup.outputs.databasePlatform == 'oracle' }}
        with:
          operation: "update"
          classpath: "src/test/resources/init-changelogs/aws"
          changeLogFile: "oracle.sql"
          username: "${{env.TH_DB_ADMIN}}"
          password: "${{env.TH_DB_PASSWD}}"
          url: "${{ env.TH_ORACLEURL_19 }}"

      - name: Restore cached Liquibase artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository/
          key: mvn-liquibase-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            mvn-liquibase-${{ github.run_id }}-

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '12' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: |
          echo "::group::Dependency Tree (PRO - liquibase-commercial)"
          mvn -B -PuseProArtifacts -DuseProArtifacts=true dependency:tree 2>&1 | grep -E "(liquibase|BUILD SUCCESS)" || true
          echo "::endgroup::"
          mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -Dprefix=aws -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_PGRESURL_12 }}' test

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '13' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -Dprefix=aws -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_PGRESURL_13 }}' test

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '14' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -Dprefix=aws -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_PGRESURL_14 }}' test

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '16' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -Dprefix=aws -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_PGRESURL_16 }}' test

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion != 'aurora' && steps.setup.outputs.databaseVersion == '17' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -Dprefix=aws -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_PGRESURL_17 }}' test

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'oracle' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_ORACLEURL_19 }}' test

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'mariadb' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_MARIADBURL_10_6 }}'  test

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'mysql' && steps.setup.outputs.databaseVersion == 'aws' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_MYSQLURL_8_0 }}' test

      - name: AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'mssql' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD_MSSQL}} -DdbUrl='${{ env.TH_MSSQLURL }}' test

      - name: AWS Aurora ${{ steps.setup.outputs.databasePlatform }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'mysql' && steps.setup.outputs.databaseVersion == 'aurora' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=${{ steps.setup.outputs.databaseVersion }} -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_AURORA_MYSQLURL }}' test

      - name: AWS Aurora ${{ steps.setup.outputs.databasePlatform }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion == 'aurora_16' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=16 -Dprefix=aurora -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_AURORA_POSTGRESQL16URL }}' test

      - name: AWS Aurora ${{ steps.setup.outputs.databasePlatform }} Test Run
        if: ${{ steps.setup.outputs.databasePlatform == 'postgresql' && steps.setup.outputs.databaseVersion == 'aurora_17' }}
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}
        run: mvn -Dtest=${{ needs.setup.outputs.testClasses }} -DconfigFile=/harness-config-cloud.yml -DdbName=${{ steps.setup.outputs.databasePlatform }} -DdbVersion=17 -Dprefix=aurora -DdbUsername=${{env.TH_DB_ADMIN}} -DdbPassword=${{env.TH_DB_PASSWD}} -DdbUrl='${{ env.TH_AURORA_POSTGRESQL17URL }}' test

      - name: Archive AWS RDS ${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }} Test Results
        uses: actions/upload-artifact@v4
        with:
          name: aws-rds-${{ steps.setup.outputs.databasePlatform }}-${{ steps.setup.outputs.databaseVersion }}-test-results
          path: build/spock-reports
