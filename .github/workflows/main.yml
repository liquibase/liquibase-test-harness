# Basic workflow with Actions

name: Default Test Execution
on:
  # Triggers the workflow on push & pull request events for the main branch. Also allows for manual triggers
  push:
    branches: [main, develop]
  pull_request:
    types:
      - opened
      - reopened
      - synchronize

  schedule:
    - cron: "0 6 * * *" # Execute every day at noon
  repository_dispatch:
    types: [test-harness]
  workflow_dispatch:
    inputs:
      distinct_id:
        description: "distinct id for the triggered run from OSS"
        required: false
      runDescription:
        description: "Description of run"
        required: false
      runDetails:
        description: "JSON details of run. Provided by automation"
        required: false
      liquibaseBranch:
        description: Liquibase branch to pull artifacts from. Leave empty to use latest commit on current branch. For forks, use the `owner:branch` format. Can support a comma separated list of branches to search for
        required: false
      liquibaseCommit:
        description: Liquibase commit to pull artifacts from. Leave empty to use "liquibaseBranch" setting.
        required: false
      testClasses:
        type: choice
        description: Test Suite or test class to run
        options:
          - LiquibaseHarnessSuiteTest
          - FoundationalHarnessSuiteTest
          - AdvancedHarnessSuiteTest
          - ChangeObjectTests
          - ChangeDataTests
          - SnapshotObjectTests
          - GenerateChangelogTest
          - FoundationalTest
      ignoreLiquibaseSnapshot:
        type: boolean
        description: Don't autoconfigure Liquibase Snapshot
      liquibaseRepo:
        description: Repo pull artifacts from. Defaults to liquibase/liquibase but also supports liquibase/liquibase-pro
        required: true
        default: "liquibase/liquibase"
      databases:
        description: Databases to start up. Comma separated list of "name"
        required: true
        default: |
          [
            "mysql-5.6",
            "mysql-5.7",
            "mysql-8",
            "mysql-8.4",
            "percona-xtradb-cluster-5.7",
            "percona-xtradb-cluster-8.0",
            "percona-xtradb-cluster-8.4",          
            "postgres-12",
            "postgres-13",
            "postgres-14",
            "postgres-15",
            "postgres-16",
            "postgres-17",
            "mariadb-10.2",
            "mariadb-10.3",
            "mariadb-10.4",
            "mariadb-10.5",
            "mariadb-10.6",
            "mariadb-10.7",
            "mariadb-11.4",          
            "mssql-2017",
            "mssql-2019",
            "mssql-2022",
            "H2Database-2.2",
            "crdb-23.1",
            "crdb-23.2",
            "crdb-24.1",
            "edb-postgres-12",
            "edb-postgres-13",
            "edb-postgres-14",
            "edb-postgres-15",
            "edb-postgres-16",
            "edb-edb-12",
            "edb-edb-13",
            "edb-edb-14",
            "edb-edb-15",
            "edb-edb-16",
            "derby",
            "sqlite",
            "hsqldb-2.5",
            "hsqldb-2.6",
            "hsqldb-2.7",
            "firebird-3",
            "firebird-4",
            "db2-luw",
            "informix-12.10",
            "informix-14.10",
            "tidb"
          ]

permissions:
  contents: write
  id-token: write
  statuses: write
  packages: read

jobs:
  authorize:
    environment: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.repo.full_name != github.repository && 'external' || 'internal' }}
    runs-on: ubuntu-latest
    steps:
      - run: true

  setup:
    name: Setup
    needs: authorize
    runs-on: ubuntu-latest
    outputs:
      liquibaseOwner: ${{ steps.configure-build.outputs.liquibaseOwner }}
      liquibaseBranch: ${{ steps.configure-build.outputs.liquibaseBranch }}
      liquibaseRepo: ${{ steps.configure-build.outputs.liquibaseRepo }}
      liquibaseSha: ${{ steps.configure-build.outputs.liquibaseSha }}
      triggeredRepo: ${{ steps.configure-build.outputs.triggeredRepo }}
      useProArtifacts: ${{ steps.configure-build.outputs.useProArtifacts }}
      communityVersion: ${{ steps.discover-version.outputs.community-version }}
      proVersion: ${{ steps.discover-version.outputs.pro-version }}
      databases:
        ${{ github.event.inputs.databases || '["mysql-5.6","mysql-5.7","mysql-8","mysql-8.4","percona-xtradb-cluster-5.7","percona-xtradb-cluster-8.0","percona-xtradb-cluster-8.4",
        "postgres-12","postgres-13","postgres-14","postgres-15","postgres-16","postgres-17","mariadb-10.2","mariadb-10.3","mariadb-10.4","mariadb-10.5","mariadb-10.6",
        "mariadb-10.7","mariadb-11.4","mssql-2017","mssql-2019","mssql-2022","H2Database-2.2","crdb-23.1","crdb-23.2","crdb-24.1",
        "edb-postgres-12","edb-postgres-13","edb-postgres-14","edb-postgres-15","edb-postgres-16",
        "edb-edb-12","edb-edb-13","edb-edb-14","edb-edb-15","edb-edb-16","derby","sqlite","hsqldb-2.5","hsqldb-2.6","hsqldb-2.7","firebird-3","firebird-4","db2-luw","informix-12.10","informix-14.10","tidb"]' }}
      testClasses: ${{ inputs.testClasses || 'LiquibaseHarnessSuiteTest' }}
    steps:
      - uses: actions/checkout@v5

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Get GitHub App token
        id: get-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.LIQUIBASE_GITHUB_APP_ID }}
          private-key: ${{ env.LIQUIBASE_GITHUB_APP_PRIVATE_KEY }}
          owner: liquibase
          repositories: liquibase,liquibase-pro,liquibase-test-harness
          permission-contents: read
          permission-actions: read
          permission-statuses: write

        #https://github.com/Codex-/return-dispatch
      - name: echo distinct ID ${{ github.event.inputs.distinct_id }}
        run: echo ${{ github.event.inputs.distinct_id }}

      - name: Configure Build
        id: configure-build
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}
          script: |
            const helper = require('./.github/util/workflow-helper.js')({github, context});

            let testBranchName = helper.getCurrentBranch();
            console.log("Running in liquibase-test-harness branch " + testBranchName);
            core.notice("Running in liquibase-test-harness branch " + testBranchName);

            // Detect which repository triggered this workflow
            const triggeredRepo = helper.getTriggeredRepository();
            console.log("Workflow triggered by repository: " + triggeredRepo);
            core.notice("Workflow triggered by repository: " + (triggeredRepo || "liquibase-test-harness (current repo)"));

            // Determine default repo based on triggered repository
            const defaultRepo = helper.getDefaultRepoForContext(triggeredRepo);
            const useProArtifacts = helper.shouldUseProArtifacts(triggeredRepo);
            console.log("Default repo for artifacts: " + defaultRepo);
            console.log("Using pro artifacts: " + useProArtifacts);

            // Use manual input if provided, otherwise use detected default
            let liquibaseRepo = "${{ github.event.inputs.liquibaseRepo }}" || defaultRepo;
            console.log("liquibaseRepo == " + liquibaseRepo);

            // Track the user's intended repository for artifact selection
            let userSelectedRepo = "${{ github.event.inputs.liquibaseRepo }}" || null;
            let intentProArtifacts = userSelectedRepo ? helper.shouldUseProArtifacts(userSelectedRepo) : useProArtifacts;
            console.log("User intended pro artifacts: " + intentProArtifacts);

            // Determine if user explicitly selected liquibase-pro (no fallback allowed)
            let isExplicitProSelection = userSelectedRepo && helper.shouldUseProArtifacts(userSelectedRepo);
            console.log("Explicit pro selection (no fallback allowed): " + isExplicitProSelection);

            core.setOutput("triggeredRepo", triggeredRepo || "liquibase-test-harness");

            let liquibaseBranchName = "${{ github.event.inputs.liquibaseBranch }}" || testBranchName + ", master";
            console.log("liquibaseBranch == " + liquibaseBranchName);
            core.setOutput("liquibaseBranch", liquibaseBranchName);

            let repoOwnerName = liquibaseRepo.split("/")[0]
            let repoName = liquibaseRepo.split("/")[1]

            let liquibaseSha = "${{ github.event.inputs.liquibaseCommit }}";
            if (!liquibaseSha) {
              console.log("No liquibaseSha passed. Looking for branch "+ liquibaseBranchName);

              try {
                let liquibaseBranchResponse = await helper.findMatchingBranch(repoOwnerName, repoName, [liquibaseBranchName, "master", "main"]);
                liquibaseSha = liquibaseBranchResponse.sha;
              } catch (error) {
                // If branch lookup fails and user explicitly selected liquibase-pro, fail hard
                // (don't fall back to community repo)
                if (isExplicitProSelection) {
                  core.error("Failed to find branch in explicitly selected liquibase-pro repository");
                  core.error("Error: " + error.message);
                  core.error("When you explicitly select liquibase-pro, artifacts must come from that repository only.");
                  core.error("Please verify that:");
                  core.error("  1. The branch exists in liquibase-pro");
                  core.error("  2. The LIQUIBOT_PAT_GPM_ACCESS token has access to liquibase-pro");
                  throw new Error("Cannot fall back from explicitly selected liquibase-pro repository");
                }

                // For triggered or default selections, allow fallback to default repository
                console.warn("Failed to find branch in " + liquibaseRepo + ": " + error.message);

                if (liquibaseRepo !== defaultRepo) {
                  console.log("Falling back to default repository: " + defaultRepo);
                  const fallbackOwner = defaultRepo.split("/")[0];
                  const fallbackRepo = defaultRepo.split("/")[1];

                  try {
                    let liquibaseBranchResponse = await helper.findMatchingBranch(fallbackOwner, fallbackRepo, [liquibaseBranchName, "master", "main"]);
                    liquibaseSha = liquibaseBranchResponse.sha;
                    liquibaseRepo = defaultRepo;
                    repoOwnerName = fallbackOwner;
                    repoName = fallbackRepo;
                    core.notice("Switched to fallback repository: " + defaultRepo + " for branch lookup, but will use " + (intentProArtifacts ? "pro" : "community") + " artifacts");
                    console.log("Successfully found branch in fallback repo");
                  } catch (fallbackError) {
                    core.error("Failed to find branch in both " + liquibaseRepo + " and fallback " + defaultRepo);
                    throw fallbackError;
                  }
                } else {
                  throw error;
                }
              }
            }
            core.setOutput("liquibaseSha", liquibaseSha);
            core.setOutput("liquibaseRepo", liquibaseRepo);
            // Use the user's intended pro artifacts setting
            core.setOutput("useProArtifacts", intentProArtifacts);
            core.setOutput("liquibaseOwner", repoOwnerName);

            let runDescription = "${{ github.event.inputs.runDescription }}";
            if (!runDescription) {
                runDescription = "None given";
            }
            core.notice("Triggered by this OSS PR: " + runDescription);

            let runDetails = null;
            if (context.payload && context.payload.inputs && context.payload.inputs.runDetails) {
                runDetails = JSON.parse(context.payload.inputs.runDetails);
            }
            if (!runDetails) {
              runDetails = {};

            }
            if (runDetails.notices) {
                for (let notice of runDetails.notices) {
                    core.notice(notice);
                }
            }

      - name: maven-settings-xml-action
        uses: whelk-io/maven-settings-xml-action@v22
        with:
          repositories: |
            [
              {
                "id": "github",
                "url": "https://maven.pkg.github.com/liquibase/liquibase",
                "releases": {
                  "enabled": "true"
                },
                "snapshots": {
                  "enabled": "true",
                  "updatePolicy": "always"
                }
              }
            ]
          servers: |
            [
              {
                "id": "github",
                "username": "liquibot",
                "password": "${{ env.LIQUIBOT_PAT_GPM_ACCESS }}"
              }
            ]

      - uses: actions/setup-java@v5
        with:
          java-version: "17"
          distribution: "temurin"
          cache: "maven"

      - name: Discover Liquibase Version
        id: discover-version
        env:
          GITHUB_TOKEN: ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}
        run: |
          echo "::group::Discover Liquibase Snapshot Version"

          # Always discover community version (org.liquibase:liquibase-core)
          echo "Resolving COMMUNITY artifacts version from liquibase/master"
          # Community artifacts use {commit-sha}-SNAPSHOT format
          # Query GitHub Packages for the latest published artifact version
          # The version format is the commit SHA from the built artifact

          PACKAGES_URL="https://maven.pkg.github.com/liquibase/liquibase/org/liquibase/liquibase-core/maven-metadata.xml"

          echo "Fetching latest artifact version from: $PACKAGES_URL"
          METADATA=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$PACKAGES_URL")

          # Extract versions in commit-SHA format (40 hex chars followed by -SNAPSHOT)
          # Filter out release-prep and other non-SHA versions
          COMMUNITY_VERSION=$(echo "$METADATA" | grep -o '<version>[a-f0-9]\{40\}-SNAPSHOT</version>' | tail -1 | sed 's/<[^>]*>//g')

          if [ -z "$COMMUNITY_VERSION" ]; then
            echo "ERROR: Could not determine latest commit-SHA version from GitHub Packages"
            echo "Looking for pattern: 40-character hex SHA followed by -SNAPSHOT"
            echo "GitHub Packages metadata response (first 500 chars):"
            echo "$METADATA" | head -c 500
            echo ""
            exit 1
          fi

          echo "Community version: $COMMUNITY_VERSION"
          echo "community-version=$COMMUNITY_VERSION" >> $GITHUB_OUTPUT

          # Pro version is always 'master' for com.liquibase:liquibase-commercial
          PRO_VERSION="master"
          echo "Pro version: $PRO_VERSION"
          echo "pro-version=$PRO_VERSION" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: Resolve Snapshot Liquibase Dependencies
        env:
          GITHUB_TOKEN: ${{ env.LIQUIBOT_PAT_GPM_ACCESS }}
        run: |
          echo "::group::Resolve Snapshot Liquibase Dependencies"
          echo "Artifact repository: ${{ steps.configure-build.outputs.liquibaseRepo }}"
          echo "Community version: ${{ steps.discover-version.outputs.community-version }}"
          echo "Pro version: ${{ steps.discover-version.outputs.pro-version }}"
          echo "Using pro artifacts: ${{ steps.configure-build.outputs.useProArtifacts }}"
          echo "::endgroup::"

          # Verify Maven settings are configured
          echo "Maven settings.xml location:"
          ls -la ~/.m2/settings.xml || echo "No settings.xml found"
          echo "Maven settings.xml content:"
          cat ~/.m2/settings.xml || echo "Could not read settings.xml"

          # Pass authentication credentials as system properties to Maven
          MAVEN_AUTH_OPTS="-Dorg.slf4j.simpleLogger.defaultLogLevel=debug"

          if [ "${{ steps.configure-build.outputs.useProArtifacts }}" = "true" ]; then
            echo "Resolving PRO artifacts from liquibase-pro repository..."
            # For pro: use community version for org.liquibase:liquibase-core and pro version for com.liquibase:liquibase-commercial
            mvn -B -Puseproartifacts \
              -Dliquibase-core.version=${{ steps.discover-version.outputs.community-version }} \
              -Dliquibase-commercial.version=${{ steps.discover-version.outputs.pro-version }} \
              $MAVEN_AUTH_OPTS \
              dependency:resolve -X 2>&1 | tee resolve.log
          else
            echo "Resolving COMMUNITY artifacts from liquibase repository..."
            mvn -B -Dliquibase-core.version=${{ steps.discover-version.outputs.community-version }} \
              $MAVEN_AUTH_OPTS \
              dependency:resolve -X 2>&1 | tee resolve.log
          fi

          echo "::notice :: Resolved Snapshot Liquibase dependencies"

      - name: Cache installed Liquibase
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository/org/liquibase/
            ~/.m2/repository/com/liquibase/
          key: mvn-liquibase-${{ github.run_id }}-${{ github.run_attempt }}

  test:
    runs-on: ubuntu-latest
    needs: [setup, authorize]
    strategy:
      fail-fast: false
      matrix:
        database: ${{ fromJson(needs.setup.outputs.databases) }}

    steps:
      - uses: actions/checkout@v5

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Get GitHub App token
        id: get-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.LIQUIBASE_GITHUB_APP_ID }}
          private-key: ${{ env.LIQUIBASE_GITHUB_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          permission-contents: write
          permission-actions: write

      - uses: actions/setup-java@v5
        with:
          java-version: "17"
          distribution: "temurin"
          cache: "maven"

      - name: maven-settings-xml-action
        uses: whelk-io/maven-settings-xml-action@v22
        with:
          repositories: |
            [
              {
                "id": "github",
                "url": "https://maven.pkg.github.com/liquibase/liquibase",
                "releases": {
                  "enabled": "true"
                },
                "snapshots": {
                  "enabled": "true",
                  "updatePolicy": "always"
                }
              }
            ]
          servers: |
            [
              {
                "id": "github",
                "username": "liquibot",
                "password": "${{ env.LIQUIBOT_PAT_GPM_ACCESS }}"
              }
            ]

      - name: Cache installed Liquibase
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository/org/liquibase/
          key: mvn-liquibase-${{ github.run_id }}-${{ github.run_attempt }}

      - name: Build ${{ matrix.database }} test infra
        working-directory: src/test/resources/docker
        run: ./create-infra.sh ${{ matrix.database }}
        env:
          REPO_URL: ${{ env.REPO_URL }}
          REPO_USER: ${{ env.REPO_USER }}
          REPO_PASSWORD: ${{ env.REPO_PASSWORD }}

      - name: ${{ matrix.database }} Test Run
        run: |
          USE_PRO_ARTIFACTS="${{ needs.setup.outputs.useProArtifacts }}"
          COMMUNITY_VERSION="${{ needs.setup.outputs.communityVersion }}"
          PRO_VERSION="${{ needs.setup.outputs.proVersion }}"

          if [ "$USE_PRO_ARTIFACTS" = "true" ]; then
            echo "Running tests with PRO artifacts"
            MAVEN_OPTS="-Puseproartifacts -DuseProArtifacts=true -Dliquibase-core.version=$COMMUNITY_VERSION -Dliquibase-commercial.version=$PRO_VERSION"
          else
            echo "Running tests with COMMUNITY artifacts"
            MAVEN_OPTS="-Dliquibase-core.version=$COMMUNITY_VERSION"
          fi

          # Run tests with appropriate profile/properties and resolved versions
          ./src/test/resources/automation-runner.sh ${{ matrix.database }} ${{ needs.setup.outputs.testClasses }} "$MAVEN_OPTS"
        env:
          LIQUIBASE_PRO_LICENSE_KEY: ${{ env.PRO_LICENSE_KEY }}

      - name: Archive ${{ matrix.database }} test results
        uses: actions/upload-artifact@v4
        if: ${{ always() }}
        with:
          name: ${{ matrix.database }}-test-results
          path: build/spock-reports

      # GitHub Actions has its own cleanup and this might be redundant
      - name: Tear down ${{ matrix.database }} test infra
        working-directory: src/test/resources/docker
        run: ./teardown-infra.sh ${{ matrix.database }}

  finish:
    name: Finish
    runs-on: ubuntu-latest
    needs: [setup, test, authorize]
    if: ${{ always() }}
    steps:
      - uses: actions/checkout@v5

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Get GitHub App token
        id: get-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.LIQUIBASE_GITHUB_APP_ID }}
          private-key: ${{ env.LIQUIBASE_GITHUB_APP_PRIVATE_KEY }}
          owner: liquibase
          repositories: liquibase
          permission-statuses: write

      - name: Generate workflow summary
        if: ${{ always() }}
        run: |
          echo "## Test Harness Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered Repository:** ${{ needs.setup.outputs.triggeredRepo }}" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts Downloaded From:** ${{ needs.setup.outputs.liquibaseRepo }}" >> $GITHUB_STEP_SUMMARY
          echo "**Liquibase Branch:** ${{ needs.setup.outputs.liquibaseBranch }}" >> $GITHUB_STEP_SUMMARY
          echo "**Liquibase Commit:** ${{ needs.setup.outputs.liquibaseSha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Build Type:** ${{ needs.setup.outputs.useProArtifacts == 'true' && 'Pro (Liquibase Secure)' || 'Community' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Test Result:** ${{ needs.test.result }}" >> $GITHUB_STEP_SUMMARY

      - name: Coordinate Liquibase-Test-Harness
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.get-token.outputs.token }}
          script: |
            const helper = require('./.github/util/workflow-helper.js')({github, context});

            console.log("result is ${{ needs.test.result }}");

            let result = "success"
            if ("${{ needs.test.result }}" != "success") {
              result = "failure";
            }

            console.log("Mark tests as "+result);
            await github.rest.repos.createCommitStatus({
              "owner": "${{ needs.setup.outputs.liquibaseOwner }}",
              "repo": "liquibase",
              "sha": "${{ needs.setup.outputs.liquibaseSha }}",
              "state": result,
              "context": "Run Test-Harness Tests",
              "description": "Test-Harness tests complete",
              "target_url": "https://github.com/liquibase/liquibase-test-harness/actions/runs/${{ github.run_id }}"
            });
